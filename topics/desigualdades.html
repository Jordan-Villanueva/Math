<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Desigualdades Matemáticas - Teoría y Gráficas</title>
  <style>
    :root { 
      --bg: #fafafa; 
      --card: #ffffff; 
      --accent: #2b7a78; 
      --muted: #666; 
      --light-accent: rgba(43, 122, 120, 0.1);
    }

    * { 
      box-sizing: border-box; 
      margin: 0; 
      padding: 0; 
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0 auto;
      max-width: 1400px;
      padding: 20px;
      line-height: 1.6;
      color: #333;
      background: linear-gradient(#f7fbfb, #eef6f6);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .container {
      width: 100%;
      margin: 0 auto;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, var(--accent), #1a5f5d);
      color: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      width: 100%;
    }

    h1 {
      font-size: 2.2rem;
      margin-bottom: 10px;
    }

    h2 {
      font-size: 1.6rem;
      margin-bottom: 15px;
      color: var(--accent);
    }

    h3 {
      font-size: 1.3rem;
      margin-bottom: 12px;
      color: var(--accent);
    }

    .subtitle {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .panel {
      background: var(--card);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      margin-bottom: 25px;
      transition: transform 0.3s ease;
      width: 100%;
    }

    .panel:hover {
      transform: translateY(-5px);
    }

    .flex-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      width: 100%;
    }

    .element-info {
      flex: 1;
      min-width: 300px;
    }

    .graphics-container {
      flex: 2;
      min-width: 300px;
    }

    .small { 
      font-size: 0.9rem; 
      color: var(--muted); 
      margin-bottom: 10px;
    }

    select, input {
      width: 100%;
      padding: 12px 15px;
      font-size: 1rem;
      margin-bottom: 15px;
      border: 2px solid #ddd;
      border-radius: 8px;
      background: white;
      color: #333;
      transition: border-color 0.3s;
    }

    select:focus, input:focus {
      border-color: var(--accent);
      outline: none;
      box-shadow: 0 0 0 3px rgba(43, 122, 120, 0.2);
    }

    .btn {
      padding: 12px 18px;
      border-radius: 8px;
      border: none;
      background: var(--accent);
      color: white;
      cursor: pointer;
      font-size: 1rem;
      transition: background 0.3s;
      width: 100%;
      margin-bottom: 10px;
    }

    .btn:hover { 
      background: #1f5f5d; 
    }

    .mutebtn {
      background: #ddd;
      color: #333;
    }

    .mutebtn:hover { 
      background: #ccc; 
    }

    .graph-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin: 15px 0;
      width: 100%;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
      min-width: 120px;
    }

    .control-group label {
      font-size: 0.95rem;
      color: var(--muted);
      font-weight: 500;
    }

    .animation-container {
      width: 100%;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      background: white;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      position: relative;
    }
    
    #graphCanvas {
      display: block;
      width: 100%;
      height: 400px;
      background: #fcfefe;
    }

    .zoom-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 15px;
      flex-wrap: wrap;
      width: 100%;
    }
    
    .zoom-btn {
      padding: 8px 14px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      font-weight: bold;
      flex: 1;
      min-width: 60px;
    }
    
    .zoom-btn:hover {
      background: #f0f0f0;
    }
    
    .zoom-info {
      font-size: 0.9rem;
      color: var(--muted);
      margin-left: 10px;
      flex: 2;
      text-align: center;
    }

    .output {
      margin-top: 20px;
      padding: 20px;
      background: #e8eaf6;
      border-radius: 8px;
      white-space: pre-wrap;
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      line-height: 1.8;
      border-left: 5px solid var(--accent);
      width: 100%;
      overflow-x: auto;
    }

    .button-group {
      display: flex;
      gap: 10px;
      width: 100%;
    }

    .button-group .btn {
      width: auto;
      flex: 1;
    }

    @media (max-width: 900px) {
      .flex-container {
        flex-direction: column;
      }
      
      .panel {
        padding: 15px;
      }
      
      h1 {
        font-size: 1.8rem;
      }
      
      h2 {
        font-size: 1.4rem;
      }
      
      #graphCanvas {
        height: 300px;
      }
      
      .zoom-controls {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .zoom-controls .zoom-btn {
        width: 100%;
      }
      
      .graph-controls {
        flex-direction: column;
      }
      
      .button-group {
        flex-direction: column;
      }
    }

    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
      
      header {
        padding: 15px;
      }
      
      .animation-container {
        margin: 10px 0;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>Desigualdades Matemáticas - Teoría y Gráficas</h1>
      <p class="subtitle">Visualiza y comprende las desigualdades matemáticas con gráficas interactivas</p>
    </header>

    <div class="flex-container">
      <div class="panel element-info">
        <h2>Selecciona tipo de desigualdad</h2>
        
        <div class="control-group">
          <label for="inequalityType">Tipo de desigualdad:</label>
          <select id="inequalityType">
            <option value="linear2d">Lineal 2D (ax + by ▢ c)</option>
            <option value="quadratic2d">Cuadrática 2D (y ▢ ax² + bx + c)</option>
            <option value="linear1d">Lineal 1D (ax + b ▢ c)</option>
            <option value="quadratic1d">Cuadrática 1D (ax² + bx + c ▢ 0)</option>
            <option value="absolute">Valor absoluto (|ax + b| ▢ c)</option>
            <option value="rational">Racional ((ax + b)/(cx + d) ▢ 0)</option>
          </select>
        </div>
        
        <div id="dynamicControls">
          <!-- Los controles dinámicos se insertarán aquí -->
        </div>
        
        <div class="control-group">
          <label for="inequalitySign">Desigualdad:</label>
          <select id="inequalitySign">
            <option value="<"><</option>
            <option value=">">></option>
            <option value="<=">≤</option>
            <option value=">=">≥</option>
          </select>
        </div>
        
        <div class="button-group">
          <button class="btn" id="plotBtn">Graficar Desigualdad</button>
          <button class="btn mutebtn" id="resetBtn">Reiniciar</button>
        </div>
        
        <div class="output" id="solutionOutput">
          La solución aparecerá aquí después de graficar.
        </div>
      </div>
      
      <div class="panel graphics-container">
        <h2>Visualización de la Desigualdad</h2>
        <p class="small">El área sombreada representa la solución de la desigualdad.</p>
        
        <div class="animation-container">
          <canvas id="graphCanvas"></canvas>
        </div>
        
        <div class="zoom-controls">
          <button class="zoom-btn" id="zoomInBtn">+ Zoom</button>
          <button class="zoom-btn" id="zoomOutBtn">- Zoom</button>
          <button class="zoom-btn" id="panLeftBtn">←</button>
          <button class="zoom-btn" id="panRightBtn">→</button>
          <button class="zoom-btn" id="panUpBtn">↑</button>
          <button class="zoom-btn" id="panDownBtn">↓</button>
          <button class="btn mutebtn" id="resetViewBtn">Vista Predeterminada</button>
          <span class="zoom-info" id="zoomLevelInfo">Zoom: 100%</span>
        </div>
        
        <div class="graph-controls">
          <div class="control-group">
            <label for="xMin">X mínimo:</label>
            <input type="number" id="xMin" value="-10" step="1">
          </div>
          <div class="control-group">
            <label for="xMax">X máximo:</label>
            <input type="number" id="xMax" value="10" step="1">
          </div>
          <div class="control-group">
            <label for="yMin">Y mínimo:</label>
            <input type="number" id="yMin" value="-10" step="1">
          </div>
          <div class="control-group">
            <label for="yMax">Y máximo:</label>
            <input type="number" id="yMax" value="10" step="1">
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Variables globales
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    let zoomLevel = 1;
    let panX = 0;
    let panY = 0;
    let xMin = -10, xMax = 10, yMin = -10, yMax = 10;
    let resizeTimeout;

    // Inicializar el tamaño del canvas
    function initCanvas() {
      const container = canvas.parentElement;
      const containerWidth = container.clientWidth;
      
      // Ajustar el tamaño del canvas con valores enteros para evitar problemas de renderizado
      canvas.width = Math.floor(containerWidth);
      canvas.height = 400;
      
      // Forzar redibujado
      drawGrid();
    }

    // Optimizar el manejo de redimensionamiento
    function handleResize() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        initCanvas();
        plotInequality();
      }, 250);
    }

    // Dibujar la cuadrícula y ejes
    function drawGrid() {
      const width = canvas.width;
      const height = canvas.height;
      
      // Limpiar el canvas
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fcfefe';
      ctx.fillRect(0, 0, width, height);
      
      // Calcular transformaciones
      const xScale = width / (xMax - xMin);
      const yScale = height / (yMax - yMin);
      
      const xOffset = -xMin * xScale;
      const yOffset = yMax * yScale;
      
      // Dibujar cuadrícula
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      
      // Líneas verticales
      for (let x = Math.ceil(xMin); x <= xMax; x++) {
        const pixelX = x * xScale + xOffset;
        ctx.beginPath();
        ctx.moveTo(pixelX, 0);
        ctx.lineTo(pixelX, height);
        ctx.stroke();
      }
      
      // Líneas horizontales
      for (let y = Math.ceil(yMin); y <= yMax; y++) {
        const pixelY = yOffset - y * yScale;
        ctx.beginPath();
        ctx.moveTo(0, pixelY);
        ctx.lineTo(width, pixelY);
        ctx.stroke();
      }
      
      // Dibujar ejes
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      
      // Eje X
      const xAxisY = yOffset;
      if (xAxisY >= 0 && xAxisY <= height) {
        ctx.beginPath();
        ctx.moveTo(0, xAxisY);
        ctx.lineTo(width, xAxisY);
        ctx.stroke();
      }
      
      // Eje Y
      const yAxisX = xOffset;
      if (yAxisX >= 0 && yAxisX <= width) {
        ctx.beginPath();
        ctx.moveTo(yAxisX, 0);
        ctx.lineTo(yAxisX, height);
        ctx.stroke();
      }
      
      // Dibujar marcas en los ejes
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Marcas en el eje X
      for (let x = Math.ceil(xMin); x <= xMax; x++) {
        if (x === 0) continue;
        const pixelX = x * xScale + xOffset;
        if (pixelX >= 0 && pixelX <= width) {
          ctx.beginPath();
          ctx.moveTo(pixelX, xAxisY - 5);
          ctx.lineTo(pixelX, xAxisY + 5);
          ctx.stroke();
          ctx.fillText(x.toString(), pixelX, xAxisY + 15);
        }
      }
      
      // Marcas en the eje Y
      for (let y = Math.ceil(yMin); y <= yMax; y++) {
        if (y === 0) continue;
        const pixelY = yOffset - y * yScale;
        if (pixelY >= 0 && pixelY <= height) {
          ctx.beginPath();
          ctx.moveTo(yAxisX - 5, pixelY);
          ctx.lineTo(yAxisX + 5, pixelY);
          ctx.stroke();
          ctx.fillText(y.toString(), yAxisX - 15, pixelY);
        }
      }
      
      // Origen
      if (xOffset >= 0 && xOffset <= width && xAxisY >= 0 && xAxisY <= height) {
        ctx.fillText("0", xOffset - 12, xAxisY + 15);
      }
    }

    // Dibujar función y área de solución
    function plotInequality() {
      // Verificar si el canvas tiene dimensiones válidas
      if (canvas.width <= 0 || canvas.height <= 0) {
        initCanvas();
      }
      
      drawGrid();
      
      const type = document.getElementById('inequalityType').value;
      const sign = document.getElementById('inequalitySign').value;
      
      const width = canvas.width;
      const height = canvas.height;
      
      // Calcular transformaciones
      const xScale = width / (xMax - xMin);
      const yScale = height / (yMax - yMin);
      
      const xOffset = -xMin * xScale;
      const yOffset = yMax * yScale;
      
      // Obtener parámetros según el tipo
      let a, b, c, d;
      
      switch(type) {
        case 'linear2d':
          a = parseFloat(document.getElementById('linear2dA').value) || 1;
          b = parseFloat(document.getElementById('linear2dB').value) || 1;
          c = parseFloat(document.getElementById('linear2dC').value) || 0;
          plotLinear2DInequality(a, b, c, sign, xScale, yScale, xOffset, yOffset);
          break;
        case 'quadratic2d':
          a = parseFloat(document.getElementById('quad2dA').value) || 1;
          b = parseFloat(document.getElementById('quad2dB').value) || 0;
          c = parseFloat(document.getElementById('quad2dC').value) || 0;
          plotQuadratic2DInequality(a, b, c, sign, xScale, yScale, xOffset, yOffset);
          break;
        case 'linear1d':
          a = parseFloat(document.getElementById('linear1dA').value) || 1;
          b = parseFloat(document.getElementById('linear1dB').value) || 0;
          c = parseFloat(document.getElementById('linear1dC').value) || 0;
          plotLinear1DInequality(a, b, c, sign, xScale, yScale, xOffset, yOffset);
          break;
        case 'quadratic1d':
          a = parseFloat(document.getElementById('quad1dA').value) || 1;
          b = parseFloat(document.getElementById('quad1dB').value) || 0;
          c = parseFloat(document.getElementById('quad1dC').value) || 0;
          plotQuadratic1DInequality(a, b, c, sign, xScale, yScale, xOffset, yOffset);
          break;
        case 'absolute':
          a = parseFloat(document.getElementById('absA').value) || 1;
          b = parseFloat(document.getElementById('absB').value) || 0;
          c = parseFloat(document.getElementById('absC').value) || 1;
          plotAbsoluteInequality(a, b, c, sign, xScale, yScale, xOffset, yOffset);
          break;
        case 'rational':
          a = parseFloat(document.getElementById('ratNumA').value) || 1;
          b = parseFloat(document.getElementById('ratNumB').value) || 0;
          c = parseFloat(document.getElementById('ratDenomA').value) || 1;
          d = parseFloat(document.getElementById('ratDenomB').value) || 0;
          plotRationalInequality(a, b, c, d, sign, xScale, yScale, xOffset, yOffset);
          break;
      }
    }

   function plotLinear2DInequality(a, b, c, sign, xScale, yScale, xOffset, yOffset) {
      const width = canvas.width;
      const height = canvas.height;

      // 1. Dibujar la cuadrícula
      drawGrid();
      
      // 2. Dibujar la línea
      ctx.strokeStyle = '#2b7a78';
      ctx.lineWidth = 3;

      // Determinar si la línea es punteada o sólida
      if (sign === '<' || sign === '>') {
        ctx.setLineDash([10, 5]); // punteada
      } else {
        ctx.setLineDash([]); // sólida
      }

      // Calcular puntos para la línea
      if (b !== 0) {
        // Para líneas no verticales: y = (c - a*x)/b
        const x1Canvas = 0;
        const x1World = xMin + x1Canvas / xScale;
        const y1World = (c - a * x1World) / b;
        const y1Canvas = height - (y1World - yMin) * yScale;

        const x2Canvas = width;
        const x2World = xMin + x2Canvas / xScale;
        const y2World = (c - a * x2World) / b;
        const y2Canvas = height - (y2World - yMin) * yScale;

        ctx.beginPath();
        ctx.moveTo(x1Canvas, y1Canvas);
        ctx.lineTo(x2Canvas, y2Canvas);
        ctx.stroke();
      } else {
        // Para líneas verticales: x = c/a
        const xWorld = c / a;
        const xCanvas = (xWorld - xMin) * xScale;
        ctx.beginPath();
        ctx.moveTo(xCanvas, 0);
        ctx.lineTo(xCanvas, height);
        ctx.stroke();
      }

      // Restaurar línea sólida
      ctx.setLineDash([]);

      // 3. LÓGICA CORREGIDA: Determinar qué lado sombrear basado en el signo
      // sin depender de un punto de prueba variable
      
      // 4. Crear imagen para el sombreado
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      
      // Evaluar cada píxel para el sombreado
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          // Convertir a coordenadas mundo
          const worldX = xMin + x / xScale;
          const worldY = yMin + (height - y) / yScale;
          
          // Evaluar desigualdad
          const value = a * worldX + b * worldY;
          
          // Determinar si este punto satisface la desigualdad
          let satisfies = false;
          switch(sign) {
            case '<':  satisfies = value < c; break;
            case '<=': satisfies = value <= c; break;
            case '>':  satisfies = value > c; break;
            case '>=': satisfies = value >= c; break;
          }
          
          // Si satisface la condición, añadir sombreado
          if (satisfies) {
            const index = (y * width + x) * 4;
            // Mezclar el color de sombreado con el color existente
            data[index] = Math.floor(data[index] * 0.7 + 43 * 0.3);     // R
            data[index + 1] = Math.floor(data[index + 1] * 0.7 + 122 * 0.3); // G
            data[index + 2] = Math.floor(data[index + 2] * 0.7 + 120 * 0.3); // B
          }
        }
      }
      
      // Dibujar el sombreado
      ctx.putImageData(imageData, 0, 0);

      // Mostrar solución
      document.getElementById('solutionOutput').textContent =
        `Desigualdad: ${a}x ${b >= 0 ? '+' : ''}${b}y ${sign} ${c}\nLa región sombreada representa todas las soluciones (x,y) que satisfacen la desigualdad.`;
    }

    // Dibujar desigualdad cuadrática 2D (y ▢ ax² + bx + c)
    function plotQuadratic2DInequality(a, b, c, sign, xScale, yScale, xOffset, yOffset) {
      const width = canvas.width;
      const height = canvas.height;
      
      // Dibujar la parábola
      ctx.strokeStyle = '#2b7a78';
      ctx.lineWidth = 3;
      
      // Determinar si la curva es punteada o sólida
      if (sign === '<' || sign === '>') {
        ctx.setLineDash([10, 5]); // punteada
      } else {
        ctx.setLineDash([]); // sólida
      }
      
      ctx.beginPath();
      
      let firstPoint = true;
      for (let pixelX = 0; pixelX <= width; pixelX++) {
        const x = (pixelX - xOffset) / xScale;
        const y = a*x*x + b*x + c;
        const pixelY = yOffset - y * yScale;
        
        if (pixelY >= 0 && pixelY <= height) {
          if (firstPoint) {
            ctx.moveTo(pixelX, pixelY);
            firstPoint = false;
          } else {
            ctx.lineTo(pixelX, pixelY);
          }
        } else {
          firstPoint = true;
        }
      }
      ctx.stroke();
      
      // Restaurar línea sólida
      ctx.setLineDash([]);
      
      // Dibujar área de solución usando prueba de punto
      ctx.fillStyle = 'rgba(43, 122, 120, 0.3)';
      
      // Crear un gradiente para mejor visualización
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, 'rgba(43, 122, 120, 0.4)');
      gradient.addColorStop(1, 'rgba(43, 122, 120, 0.1)');
      ctx.fillStyle = gradient;
      
      ctx.beginPath();
      for (let pixelX = 0; pixelX <= width; pixelX++) {
        const x = (pixelX - xOffset) / xScale;
        const y = a*x*x + b*x + c;
        const pixelY = yOffset - y * yScale;
        
        if (pixelX === 0) {
          ctx.moveTo(pixelX, pixelY);
        } else {
          ctx.lineTo(pixelX, pixelY);
        }
      }
      
      // Completar el área en la dirección correcta según el signo
      if (sign === '<' || sign === '<=') {
        // Sombrear por debajo de la parábola
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
      } else {
        // Sombrear por encima de la parábola
        ctx.lineTo(width, 0);
        ctx.lineTo(0, 0);
      }
      
      ctx.closePath();
      ctx.fill();
      
      // Mostrar solución
      let solutionText = `Desigualdad: y ${sign} ${a}x² ${b >= 0 ? '+' : ''}${b}x ${c >= 0 ? '+' : ''}${c}\n`;
      solutionText += `La región sombreada representa todas las soluciones (x,y) que satisfacen la desigualdad.`;
      
      document.getElementById('solutionOutput').textContent = solutionText;
    }

    // Dibujar desigualdad lineal 1D (ax + b ▢ c)
    function plotLinear1DInequality(a, b, c, sign, xScale, yScale, xOffset, yOffset) {
      const width = canvas.width;
      const height = canvas.height;
      
      // Calcular el valor de x que satisface ax + b = c
      const solutionX = (c - b) / a;
      const pixelX = solutionX * xScale + xOffset;
      
      // Dibujar la línea con estilo diferente según la desigualdad
      ctx.strokeStyle = '#2b7a78';
      ctx.lineWidth = 3;
      
      // Línea continua para <= o >=, punteada para < o >
      if (sign === '<=' || sign === '>=') {
        ctx.setLineDash([]); // Línea sólida
      } else {
        ctx.setLineDash([5, 5]); // Línea punteada
      }
      
      ctx.beginPath();
      ctx.moveTo(pixelX, 0);
      ctx.lineTo(pixelX, height);
      ctx.stroke();
      ctx.setLineDash([]); // Restaurar línea sólida
      
      // Dibujar área de solución
      ctx.fillStyle = 'rgba(43, 122, 120, 0.3)';
      
      // Determinar qué lado sombrear según la desigualdad
      let solutionRegion;
      
      if (a > 0) {
        if (sign === '<' || sign === '<=') {
          solutionRegion = { start: 0, end: pixelX };
        } else {
          solutionRegion = { start: pixelX, end: width };
        }
      } else {
        if (sign === '<' || sign === '<=') {
          solutionRegion = { start: pixelX, end: width };
        } else {
          solutionRegion = { start: 0, end: pixelX };
        }
      }
      
      // Dibujar la región solución
      ctx.beginPath();
      ctx.rect(solutionRegion.start, 0, solutionRegion.end - solutionRegion.start, height);
      ctx.fill();
      
      // Dibujar un punto en el valor crítico para <= o >=
      if (sign === '<=' || sign === '>=') {
        ctx.fillStyle = '#2b7a78';
        ctx.beginPath();
        ctx.arc(pixelX, height / 2, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Mostrar solución
      let solutionText = `Desigualdad: ${a}x ${b >= 0 ? '+' : ''}${b} ${sign} ${c}\n`;
      
      if (a !== 0) {
        if (sign === '<' || sign === '<=') {
          solutionText += `x ${sign} ${solutionX.toFixed(2)}`;
        } else {
          solutionText += `x ${sign} ${solutionX.toFixed(2)}`;
        }
        
        // Añadir representación de intervalo
        if (a > 0) {
          if (sign === '<' || sign === '<=') {
            solutionText += `\nEn notación de intervalo: (-∞, ${solutionX.toFixed(2)}${sign === '<=' ? ']' : ')'}`;
          } else {
            solutionText += `\nEn notación de intervalo: (${solutionX.toFixed(2)}, ∞)`;
          }
        } else {
          if (sign === '<' || sign === '<=') {
            solutionText += `\nEn notación de intervalo: (${solutionX.toFixed(2)}, ∞)`;
          } else {
            solutionText += `\nEn notación de intervalo: (-∞, ${solutionX.toFixed(2)}${sign === '>=' ? ']' : ')'}`;
          }
        }
      } else {
        solutionText += (b > c) ? "Siempre verdadero" : "Nunca verdadero";
      }
      
      document.getElementById('solutionOutput').textContent = solutionText;
    }

    // Dibujar desigualdad cuadrática 1D (ax² + bx + c ▢ 0)
    function plotQuadratic1DInequality(a, b, c, sign, xScale, yScale, xOffset, yOffset) {
      const width = canvas.width;
      const height = canvas.height;
      
      // Dibujar la parábola
      ctx.strokeStyle = '#2b7a78';
      ctx.lineWidth = 3;
      
      // Determinar si la curva es punteada o sólida
      if (sign === '<' || sign === '>') {
        ctx.setLineDash([10, 5]); // punteada
      } else {
        ctx.setLineDash([]); // sólida
      }
      
      ctx.beginPath();
      
      let firstPoint = true;
      for (let pixelX = 0; pixelX <= width; pixelX++) {
        const x = (pixelX - xOffset) / xScale;
        const y = a*x*x + b*x + c;
        const pixelY = yOffset - y * yScale;
        
        if (pixelY >= 0 && pixelY <= height) {
          if (firstPoint) {
            ctx.moveTo(pixelX, pixelY);
            firstPoint = false;
          } else {
            ctx.lineTo(pixelX, pixelY);
          }
        } else {
          firstPoint = true;
        }
      }
      ctx.stroke();
      
      // Restaurar línea sólida
      ctx.setLineDash([]);
      
      // Encontrar las raíces para determinar los intervalos
      const discriminant = b*b - 4*a*c;
      let root1, root2;
      
      if (discriminant >= 0) {
        root1 = (-b - Math.sqrt(discriminant)) / (2*a);
        root2 = (-b + Math.sqrt(discriminant)) / (2*a);
        
        // Asegurar que root1 <= root2
        if (root1 > root2) {
          [root1, root2] = [root2, root1];
        }
      }
      
      // Dibujar área de solución
      ctx.fillStyle = 'rgba(43, 122, 120, 0.3)';
      
      if (discriminant < 0) {
        // No hay raíces reales
        if ((a > 0 && (sign === '>' || sign === '>=')) || 
            (a < 0 && (sign === '<' || sign === '<='))) {
          // La parábola siempre está por encima del eje x (a>0) o siempre por debajo (a<0)
          ctx.beginPath();
          ctx.rect(0, 0, width, height);
          ctx.fill();
        }
        // En otros casos, no hay solución
      } else {
        // Hay raíces reales
        const pixelRoot1 = root1 * xScale + xOffset;
        const pixelRoot2 = root2 * xScale + xOffset;
        
        if (a > 0) {
          if (sign === '>' || sign === '>=') {
            // Solución: x < root1 o x > root2
            ctx.beginPath();
            ctx.rect(0, 0, pixelRoot1, height);
            ctx.rect(pixelRoot2, 0, width - pixelRoot2, height);
            ctx.fill();
          } else {
            // Solución: root1 < x < root2
            ctx.beginPath();
            ctx.rect(pixelRoot1, 0, pixelRoot2 - pixelRoot1, height);
            ctx.fill();
          }
        } else {
          if (sign === '>' || sign === '>=') {
            // Solución: root1 < x < root2
            ctx.beginPath();
            ctx.rect(pixelRoot1, 0, pixelRoot2 - pixelRoot1, height);
            ctx.fill();
          } else {
            // Solución: x < root1 o x > root2
            ctx.beginPath();
            ctx.rect(0, 0, pixelRoot1, height);
            ctx.rect(pixelRoot2, 0, width - pixelRoot2, height);
            ctx.fill();
          }
        }
      }
      
      // Mostrar solución
      let solutionText = `Desigualdad: ${a}x² ${b >= 0 ? '+' : ''}${b}x ${c >= 0 ? '+' : ''}${c} ${sign} 0\n`;
      
      if (discriminant < 0) {
        if ((a > 0 && (sign === '>' || sign === '>=')) || 
            (a < 0 && (sign === '<' || sign === '<='))) {
          solutionText += "Solución: Todos los números reales";
        } else {
          solutionText += "Solución: No hay solución real";
        }
      } else if (discriminant === 0) {
        if ((a > 0 && (sign === '>' || sign === '>=')) || 
            (a < 0 && (sign === '<' || sign === '<='))) {
          solutionText += `Solución: x ≠ ${root1.toFixed(2)}`;
        } else if (sign === '=') {
          solutionText += `Solución: x = ${root1.toFixed(2)}`;
        } else {
          solutionText += "Solución: No hay solución";
        }
      } else {
        if (a > 0) {
          if (sign === '>' || sign === '>=') {
            solutionText += `Solución: x ≤ ${root1.toFixed(2)} o x ≥ ${root2.toFixed(2)}`;
          } else {
            solutionText += `Solución: ${root1.toFixed(2)} ≤ x ≤ ${root2.toFixed(2)}`;
          }
        } else {
          if (sign === '>' || sign === '>=') {
            solutionText += `Solución: ${root1.toFixed(2)} ≤ x ≤ ${root2.toFixed(2)}`;
          } else {
            solutionText += `Solución: x ≤ ${root1.toFixed(2)} o x ≥ ${root2.toFixed(2)}`;
          }
        }
      }
      
      document.getElementById('solutionOutput').textContent = solutionText;
    }

    // Dibujar desigualdad con valor absoluto (|ax + b| ▢ c)
    function plotAbsoluteInequality(a, b, c, sign, xScale, yScale, xOffset, yOffset) {
      const width = canvas.width;
      const height = canvas.height;
      
      // Dibujar la función
      ctx.strokeStyle = '#2b7a78';
      ctx.lineWidth = 3;
      
      // Determinar si la función es punteada o sólida
      if (sign === '<' || sign === '>') {
        ctx.setLineDash([10, 5]); // punteada
      } else {
        ctx.setLineDash([]); // sólida
      }
      
      ctx.beginPath();
      
      let firstPoint = true;
      for (let pixelX = 0; pixelX <= width; pixelX++) {
        const x = (pixelX - xOffset) / xScale;
        const y = Math.abs(a*x + b);
        const pixelY = yOffset - y * yScale;
        
        if (pixelY >= 0 && pixelY <= height) {
          if (firstPoint) {
            ctx.moveTo(pixelX, pixelY);
            firstPoint = false;
          } else {
            ctx.lineTo(pixelX, pixelY);
          }
        } else {
          firstPoint = true;
        }
      }
      ctx.stroke();
      
      // Restaurar línea sólida
      ctx.setLineDash([]);
      
      // Resolver la desigualdad
      let solutionText = `Desigualdad: |${a}x ${b >= 0 ? '+' : ''}${b}| ${sign} ${c}\n`;
      
      if (c < 0) {
        if (sign === '<' || sign === '<=') {
          solutionText += "Solución: No hay solución (un valor absoluto nunca es negativo)";
          document.getElementById('solutionOutput').textContent = solutionText;
          return;
        } else {
          solutionText += "Solución: Todos los números reales";
          // Sombrear toda el área
          ctx.fillStyle = 'rgba(43, 122, 120, 0.3)';
          ctx.beginPath();
          ctx.rect(0, 0, width, height);
          ctx.fill();
          document.getElementById('solutionOutput').textContent = solutionText;
          return;
        }
      }
      
      // Encontrar los puntos críticos
      const point1 = (c - b) / a;
      const point2 = (-c - b) / a;
      
      const pixelPoint1 = point1 * xScale + xOffset;
      const pixelPoint2 = point2 * xScale + xOffset;
      
      // Dibujar área de solución
      ctx.fillStyle = 'rgba(43, 122, 120, 0.3)';
      
      if (sign === '<' || sign === '<=') {
        // Solución: -c < ax + b < c
        if (point1 < point2) {
          ctx.beginPath();
          ctx.rect(pixelPoint1, 0, pixelPoint2 - pixelPoint1, height);
          ctx.fill();
          solutionText += `Solución: ${point1.toFixed(2)} ≤ x ≤ ${point2.toFixed(2)}`;
        } else {
          ctx.beginPath();
          ctx.rect(pixelPoint2, 0, pixelPoint1 - pixelPoint2, height);
          ctx.fill();
          solutionText += `Solución: ${point2.toFixed(2)} ≤ x ≤ ${point1.toFixed(2)}`;
        }
      } else {
        // Solución: ax + b < -c o ax + b > c
        if (point1 < point2) {
          ctx.beginPath();
          ctx.rect(0, 0, pixelPoint1, height);
          ctx.rect(pixelPoint2, 0, width - pixelPoint2, height);
          ctx.fill();
          solutionText += `Solución: x ≤ ${point1.toFixed(2)} o x ≥ ${point2.toFixed(2)}`;
        } else {
          ctx.beginPath();
          ctx.rect(0, 0, pixelPoint2, height);
          ctx.rect(pixelPoint1, 0, width - pixelPoint1, height);
          ctx.fill();
          solutionText += `Solución: x ≤ ${point2.toFixed(2)} o x ≥ ${point1.toFixed(2)}`;
        }
      }
      
      document.getElementById('solutionOutput').textContent = solutionText;
    }

    // Dibujar desigualdad racional ((ax + b)/(cx + d) ▢ 0)
    function plotRationalInequality(a, b, c, d, sign, xScale, yScale, xOffset, yOffset) {
      const width = canvas.width;
      const height = canvas.height;
      
      // Dibujar la función
      ctx.strokeStyle = '#2b7a78';
      ctx.lineWidth = 3;
      
      // Determinar si la función es punteada o sólida
      if (sign === '<' || sign === '>') {
        ctx.setLineDash([10, 5]); // punteada
      } else {
        ctx.setLineDash([]); // sólida
      }
      
      ctx.beginPath();
      
      let firstPoint = true;
      let previousY = null;
      
      for (let pixelX = 0; pixelX <= width; pixelX++) {
        const x = (pixelX - xOffset) / xScale;
        
        // Evitar división por cero
        if (c*x + d === 0) {
          firstPoint = true;
          previousY = null;
          continue;
        }
        
        const y = (a*x + b) / (c*x + d);
        const pixelY = yOffset - y * yScale;
        
        // Saltar valores extremos
        if (Math.abs(y) > 100) {
          firstPoint = true;
          previousY = null;
          continue;
        }
        
        if (pixelY >= 0 && pixelY <= height) {
          if (firstPoint) {
            ctx.moveTo(pixelX, pixelY);
            firstPoint = false;
          } else if (previousY !== null && Math.abs(pixelY - previousY) < 100) {
            ctx.lineTo(pixelX, pixelY);
          } else {
            ctx.moveTo(pixelX, pixelY);
          }
          previousY = pixelY;
        } else {
          firstPoint = true;
          previousY = null;
        }
      }
      ctx.stroke();
      
      // Restaurar línea sólida
      ctx.setLineDash([]);
      
      // Encontrar los puntos críticos
      const zeroPoint = -b / a;
      const asymptote = -d / c;
      
      const pixelZero = zeroPoint * xScale + xOffset;
      const pixelAsymptote = asymptote * xScale + xOffset;
      
      // Determinar los intervalos de solución
      ctx.fillStyle = 'rgba(43, 122, 120, 0.3)';
      
      if (sign === '>' || sign === '>=') {
        if (zeroPoint < asymptote) {
          ctx.beginPath();
          ctx.rect(0, 0, pixelZero, height);
          ctx.rect(pixelAsymptote, 0, width - pixelAsymptote, height);
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.rect(pixelAsymptote, 0, pixelZero - pixelAsymptote, height);
          ctx.fill();
        }
      } else {
        if (zeroPoint < asymptote) {
          ctx.beginPath();
          ctx.rect(pixelZero, 0, pixelAsymptote - pixelZero, height);
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.rect(0, 0, pixelAsymptote, height);
          ctx.rect(pixelZero, 0, width - pixelZero, height);
          ctx.fill();
        }
      }
      
      // Mostrar solución
      let solutionText = `Desigualdad: (${a}x ${b >= 0 ? '+' : ''}${b})/(${c*x} ${d >= 0 ? '+' : ''}${d}) ${sign} 0\n`;
      
      if (zeroPoint < asymptote) {
        if (sign === '>' || sign === '>=') {
          solutionText += `Solución: x < ${zeroPoint.toFixed(2)} o x > ${asymptote.toFixed(2)}`;
        } else {
          solutionText += `Solución: ${zeroPoint.toFixed(2)} < x < ${asymptote.toFixed(2)}`;
        }
      } else {
        if (sign === '>' || sign === '>=') {
          solutionText += `Solución: ${asymptote.toFixed(2)} < x < ${zeroPoint.toFixed(2)}`;
        } else {
          solutionText += `Solución: x < ${asymptote.toFixed(2)} o x > ${zeroPoint.toFixed(2)}`;
        }
      }
      
      document.getElementById('solutionOutput').textContent = solutionText;
    }

    // Actualizar controles según el tipo de desigualdad
    function updateControls() {
      const type = document.getElementById('inequalityType').value;
      const controlsContainer = document.getElementById('dynamicControls');
      
      let controlsHTML = '';
      
      switch(type) {
        case 'linear2d':
          controlsHTML = `
            <div class="control-group">
              <label for="linear2dA">Coeficiente a (de x):</label>
              <input type="number" id="linear2dA" value="1" step="0.1">
            </div>
            <div class="control-group">
              <label for="linear2dB">Coeficiente b (de y):</label>
              <input type="number" id="linear2dB" value="1" step="0.1">
            </div>
            <div class="control-group">
              <label for="linear2dC">Constante c:</label>
              <input type="number" id="linear2dC" value="0" step="0.1">
            </div>
          `;
          break;
        case 'quadratic2d':
          controlsHTML = `
            <div class="control-group">
              <label for="quad2dA">Coeficiente a:</label>
              <input type="number" id="quad2dA" value="1" step="0.1">
            </div>
            <div class="control-group">
              <label for="quad2dB">Coeficiente b:</label>
              <input type="number" id="quad2dB" value="0" step="0.1">
            </div>
            <div class="control-group">
              <label for="quad2dC">Coeficiente c:</label>
              <input type="number" id="quad2dC" value="0" step="0.1">
            </div>
          `;
          break;
        case 'linear1d':
          controlsHTML = `
            <div class="control-group">
              <label for="linear1dA">Coeficiente a:</label>
              <input type="number" id="linear1dA" value="1" step="0.1">
            </div>
            <div class="control-group">
              <label for="linear1dB">Coeficiente b:</label>
              <input type="number" id="linear1dB" value="0" step="0.1">
            </div>
            <div class="control-group">
              <label for="linear1dC">Constante c:</label>
              <input type="number" id="linear1dC" value="0" step="0.1">
            </div>
          `;
          break;
        case 'quadratic1d':
          controlsHTML = `
            <div class="control-group">
              <label for="quad1dA">Coeficiente a:</label>
              <input type="number" id="quad1dA" value="1" step="0.1">
            </div>
            <div class="control-group">
              <label for="quad1dB">Coeficiente b:</label>
              <input type="number" id="quad1dB" value="0" step="0.1">
            </div>
            <div class="control-group">
              <label for="quad1dC">Coeficiente c:</label>
              <input type="number" id="quad1dC" value="0" step="0.1">
            </div>
          `;
          break;
        case 'absolute':
          controlsHTML = `
            <div class="control-group">
              <label for="absA">Coeficiente a:</label>
              <input type="number" id="absA" value="1" step="0.1">
            </div>
            <div class="control-group">
              <label for="absB">Coeficiente b:</label>
              <input type="number" id="absB" value="0" step="0.1">
            </div>
            <div class="control-group">
              <label for="absC">Constante c:</label>
              <input type="number" id="absC" value="1" step="0.1">
            </div>
          `;
          break;
        case 'rational':
          controlsHTML = `
            <div class="control-group">
              <label for="ratNumA">Numerador a:</label>
              <input type="number" id="ratNumA" value="1" step="0.1">
            </div>
            <div class="control-group">
              <label for="ratNumB">Numerador b:</label>
              <input type="number" id="ratNumB" value="0" step="0.1">
            </div>
            <div class="control-group">
              <label for="ratDenomA">Denominador c:</label>
              <input type="number" id="ratDenomA" value="1" step="0.1">
            </div>
            <div class="control-group">
              <label for="ratDenomB">Denominador d:</label>
              <input type="number" id="ratDenomB" value="0" step="0.1">
            </div>
          `;
          break;
      }
      
      controlsContainer.innerHTML = controlsHTML;
    }

    // Funciones de zoom y desplazamiento
    function zoomIn() {
      const centerX = (xMin + xMax) / 2;
      const centerY = (yMin + yMax) / 2;
      const rangeX = (xMax - xMin) * 0.8;
      const rangeY = (yMax - yMin) * 0.8;
      
      xMin = centerX - rangeX / 2;
      xMax = centerX + rangeX / 2;
      yMin = centerY - rangeY / 2;
      yMax = centerY + rangeY / 2;
      
      updateView();
    }

    function zoomOut() {
      const centerX = (xMin + xMax) / 2;
      const centerY = (yMin + yMax) / 2;
      const rangeX = (xMax - xMin) / 0.8;
      const rangeY = (yMax - yMin) / 0.8;
      
      xMin = centerX - rangeX / 2;
      xMax = centerX + rangeX / 2;
      yMin = centerY - rangeY / 2;
      yMax = centerY + rangeY / 2;
      
      updateView();
    }

    function panLeft() {
      const rangeX = xMax - xMin;
      xMin -= rangeX * 0.1;
      xMax -= rangeX * 0.1;
      updateView();
    }

    function panRight() {
      const rangeX = xMax - xMin;
      xMin += rangeX * 0.1;
      xMax += rangeX * 0.1;
      updateView();
    }

    function panUp() {
      const rangeY = yMax - yMin;
      yMin += rangeY * 0.1;
      yMax += rangeY * 0.1;
      updateView();
    }

    function panDown() {
      const rangeY = yMax - yMin;
      yMin -= rangeY * 0.1;
      yMax -= rangeY * 0.1;
      updateView();
    }

    function resetView() {
      xMin = -10;
      xMax = 10;
      yMin = -10;
      yMax = 10;
      updateView();
    }

    function updateView() {
      // Actualizar los valores de los inputs
      document.getElementById('xMin').value = Math.round(xMin * 100) / 100;
      document.getElementById('xMax').value = Math.round(xMax * 100) / 100;
      document.getElementById('yMin').value = Math.round(yMin * 100) / 100;
      document.getElementById('yMax').value = Math.round(yMax * 100) / 100;
      
      // Calcular nivel de zoom aproximado
      const originalRange = 20; // Rango original de -10 a 10
      const currentRange = xMax - xMin;
      zoomLevel = originalRange / currentRange;
      
      // Actualizar información de zoom
      document.getElementById('zoomLevelInfo').textContent = `Zoom: ${Math.round(zoomLevel * 100)}%`;
      
      // Redibujar
      plotInequality();
    }

    // Inicializar la aplicación
    function init() {
      initCanvas();
      updateControls();
      
      // Ajustar el canvas cuando cambia el tamaño de la ventana
      window.addEventListener('resize', handleResize);
      
      // Event listeners
      document.getElementById('inequalityType').addEventListener('change', updateControls);
      document.getElementById('plotBtn').addEventListener('click', plotInequality);
      document.getElementById('resetBtn').addEventListener('click', function() {
        resetView();
        updateControls();
      });
      document.getElementById('resetViewBtn').addEventListener('click', resetView);
      
      document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
      document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
      document.getElementById('panLeftBtn').addEventListener('click', panLeft);
      document.getElementById('panRightBtn').addEventListener('click', panRight);
      document.getElementById('panUpBtn').addEventListener('click', panUp);
      document.getElementById('panDownBtn').addEventListener('click', panDown);
      
      // Event listeners para los inputs de rango
      document.getElementById('xMin').addEventListener('change', function() {
        xMin = parseFloat(this.value);
        plotInequality();
      });
      
      document.getElementById('xMax').addEventListener('change', function() {
        xMax = parseFloat(this.value);
        plotInequality();
      });
      
      document.getElementById('yMin').addEventListener('change', function() {
        yMin = parseFloat(this.value);
        plotInequality();
      });
      
      document.getElementById('yMax').addEventListener('change', function() {
        yMax = parseFloat(this.value);
        plotInequality();
      });
      
      // Dibujar la cuadrícula inicial
      drawGrid();
      
      // Forzar un redibujado después de la carga completa
      setTimeout(() => {
        initCanvas();
        drawGrid();
      }, 100);
    }

    // Iniciar cuando el documento esté cargado
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
